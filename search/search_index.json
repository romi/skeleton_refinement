{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Skeleton refinement","text":"<p>For full documentation of the ROMI project visit docs.romi-project.eu.</p>"},{"location":"#about","title":"About","text":"<p>This library is intended to provide the implementation of a skeleton refinement method published here:</p> <p>Chaudhury A. and Godin C. (2020) Skeletonization of Plant Point Cloud Data Using Stochastic Optimization Framework. Front. Plant Sci. 11:773. doi: 10.3389/fpls.2020.00773.</p>"},{"location":"#installation","title":"Installation","text":"<p>We strongly advise to create isolated environments to install the ROMI libraries.</p> <p>We often use <code>conda</code> as an environment and python package manager. If you do not yet have <code>miniconda3</code> installed on your system, have a look here.</p> <p>The <code>skeleton_refinement</code> package is available from the <code>romi-eu</code> channel.</p>"},{"location":"#existing-conda-environment","title":"Existing conda environment","text":"<p>To install the <code>skeleton_refinement</code> conda package in an existing environment, first activate it, then proceed as follows: <pre><code>conda install skeleton_refinement -c romi-eu\n</code></pre></p>"},{"location":"#new-conda-environment","title":"New conda environment","text":"<p>To install the <code>skeleton_refinement</code> conda package in a new environment, here named <code>romi</code>, proceed as follows: <pre><code>conda create -n romi skeleton_refinement -c romi-eu\n</code></pre></p>"},{"location":"#installation-from-sources","title":"Installation from sources","text":"<p>To install this library, simply clone the repo and use <code>pip</code> to install it and the required dependencies. Again, we strongly advise to create a <code>conda</code> environment.</p> <p>All this can be done as follows: <pre><code>git clone https://github.com/romi/skeleton_refinement.git\ncd skeleton_refinement\nconda create -n skeleton_refinement 'python =3.10'\nconda activate skeleton_refinement  # do not forget to activate your environment!\npython -m pip install -e .  # install the sources\n</code></pre></p> <p>Note that the <code>-e</code> option is to install the <code>skeleton_refinement</code> sources in \"developer mode\". That is, if you make changes to the source code of <code>skeleton_refinement</code> you will not have to <code>pip install</code> it again.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#example-dataset","title":"Example dataset","text":"<p>First download an example dataset to play with: <pre><code>cd tmp/\nwget https://zenodo.org/records/10379172/files/real_plant_analyzed.zip\n\nunzip real_plant_analyzed.zip\n</code></pre></p>"},{"location":"#cli","title":"CLI","text":"<pre><code>refine_skeleton \\\n  real_plant_analyzed/PointCloud_1_0_1_0_10_0_7ee836e5a9/PointCloud.ply \\\n  real_plant_analyzed/CurveSkeleton__TriangleMesh_0393cb5708/CurveSkeleton.json \\\n  real_plant_analyzed/optimized_skeleton.txt\n</code></pre>"},{"location":"#python-api","title":"Python API","text":"<p>Here is a minimal example how to use the <code>skeleton_refinement</code> library in Python:</p> <pre><code>from skeleton_refinement.stochastic_registration import perform_registration\nfrom skeleton_refinement.utilities import load_json, load_ply\n\npcd = load_ply(\"real_plant_analyzed/PointCloud_1_0_1_0_10_0_7ee836e5a9/PointCloud.ply\")\nskel = load_json(\"real_plant_analyzed/CurveSkeleton__TriangleMesh_0393cb5708/CurveSkeleton.json\", \"points\")\n# Perform stochastic optimization\nrefined_skel = perform_registration(pcd, skel)\n\nimport matplotlib.pyplot as plt\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\nax.scatter(*pcd.T, marker='.', color='black')\nax.scatter(*skel.T, marker='o', color='r')\nax.scatter(*refined_skel.T, marker='o', color='b')\nax.set_aspect('equal')\nplt.show()\n</code></pre>"},{"location":"dev/","title":"Developers &amp; contributors","text":""},{"location":"dev/#unitary-tests","title":"Unitary tests","text":"<p>Some tests are defined in the <code>tests</code> directory. We use <code>nose2</code> to call them as follows:</p> <pre><code>nose2 -v -C\n</code></pre> <p>Notes:</p> <ul> <li>the configuration file used by <code>nose2</code> is <code>unittests.cfg</code></li> <li>the <code>-C</code> option generate a coverage report, as defined by the <code>.coveragerc</code> file.</li> <li>this requires the <code>nose2</code> &amp; <code>coverage</code> packages listed in the <code>requirements.txt</code> file.</li> </ul> <p>You first have to install the library from sources as explained here.</p>"},{"location":"dev/#conda-packaging","title":"Conda packaging","text":"<p>Start by installing the required <code>conda-build</code> &amp; <code>anaconda-client</code> conda packages in the <code>base</code> environment as follows: <pre><code>conda install -n base conda-build anaconda-client\n</code></pre></p>"},{"location":"dev/#build-a-conda-package","title":"Build a conda package","text":"<p>To build the <code>romitask</code> conda package, from the root directory of the repository and the <code>base</code> conda environment, run: <pre><code>conda build conda/recipe/ -c conda-forge --user romi-eu\n</code></pre></p> <p>If you are struggling with some of the modifications you made to the recipe,  notably when using environment variables or Jinja2 stuffs, you can always render the recipe with: <pre><code>conda render conda/recipe/\n</code></pre></p> <p>The official documentation for <code>conda-render</code> can be found here.</p>"},{"location":"dev/#upload-a-conda-package","title":"Upload a conda package","text":"<p>To upload the built package, you need a valid account (here <code>romi-eu</code>) on anaconda.org &amp; to log ONCE with <code>anaconda login</code>, then: <pre><code>anaconda upload ~/miniconda3/conda-bld/linux-64/skeleton_refinement*.tar.bz2 --user romi-eu\n</code></pre></p>"},{"location":"dev/#clean-builds","title":"Clean builds","text":"<p>To clean the source and build intermediates: <pre><code>conda build purge\n</code></pre></p> <p>To clean ALL the built packages &amp; build environments: <pre><code>conda build purge-all\n</code></pre></p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>skeleton_refinement<ul> <li>cli<ul> <li>refine_skeleton</li> </ul> </li> <li>deformable_registration</li> <li>expectation_maximization_registration</li> <li>stochastic_registration</li> <li>utilities</li> </ul> </li> </ul>"},{"location":"reference/skeleton_refinement/","title":"skeleton_refinement","text":""},{"location":"reference/skeleton_refinement/deformable_registration/","title":"deformable_registration","text":"<p>This is a part of the implementation of the stochastic registration algorithm based on the following paper: Andriy Myronenko and Xubo Song, \"Point set registration: Coherent Point drift\", IEEE Transactions on Pattern Analysis and Machine Intelligence. 32 (2): 2262-2275, 2010.</p> <p>The library is based on the python implementation of the paper in pycpd package.</p>"},{"location":"reference/skeleton_refinement/deformable_registration/#skeleton_refinement.deformable_registration.DeformableRegistration","title":"<code>DeformableRegistration(alpha=ALPHA, beta=BETA, *args, **kwargs)</code>","text":"<p>             Bases: <code>ExpectationMaximizationRegistration</code></p> <p>Implement a deformable registration by Expectation-Maximization.</p> <p>Attributes:</p> Name Type Description <code>alpha</code> <code>float</code> <p>???.</p> <code>beta</code> <code>float</code> <p>???.</p> <code>W</code> <code>ndarray</code> <p>???.</p> <code>G</code> <code>ndarray</code> <p>???.</p> <p>Initialize the deformable registration algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>???. Defaults to <code>ALPHA</code>.</p> <code>ALPHA</code> <code>beta</code> <code>float</code> <p>???. Defaults to <code>BETA</code>.</p> <code>BETA</code> Source code in <code>skeleton_refinement/deformable_registration.py</code> <pre><code>def __init__(self, alpha=ALPHA, beta=BETA, *args, **kwargs):\n    \"\"\"Initialize the deformable registration algorithm.\n\n    Parameters\n    ----------\n    alpha : float, optional\n        ???.\n        Defaults to `ALPHA`.\n    beta : float, optional\n        ???.\n        Defaults to `BETA`.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.alpha = ALPHA if alpha is None else alpha\n    self.beta = BETA if alpha is None else beta\n    self.W = np.zeros((self.M, self.D))\n    self.G = gaussian_kernel(self.Y, self.beta)\n</code></pre>"},{"location":"reference/skeleton_refinement/deformable_registration/#skeleton_refinement.deformable_registration.DeformableRegistration.get_registration_parameters","title":"<code>get_registration_parameters()</code>","text":"<p>Retrieve the registration parameters <code>G</code> &amp; <code>W</code>.</p> Source code in <code>skeleton_refinement/deformable_registration.py</code> <pre><code>def get_registration_parameters(self):\n    \"\"\"Retrieve the registration parameters `G` &amp; `W`.\"\"\"\n    return self.G, self.W\n</code></pre>"},{"location":"reference/skeleton_refinement/deformable_registration/#skeleton_refinement.deformable_registration.DeformableRegistration.transform_point_cloud","title":"<code>transform_point_cloud(Y=None)</code>","text":"<p>???</p> Source code in <code>skeleton_refinement/deformable_registration.py</code> <pre><code>def transform_point_cloud(self, Y=None):\n    \"\"\"???\"\"\"\n    if Y is None:\n        self.TY = self.Y + np.dot(self.G, self.W)\n        return\n    else:\n        return Y + np.dot(self.G, self.W)\n</code></pre>"},{"location":"reference/skeleton_refinement/deformable_registration/#skeleton_refinement.deformable_registration.DeformableRegistration.update_transform","title":"<code>update_transform()</code>","text":"<p>???</p> Source code in <code>skeleton_refinement/deformable_registration.py</code> <pre><code>def update_transform(self):\n    \"\"\"???\"\"\"\n    A = np.dot(np.diag(self.P1), self.G) + self.alpha * self.sigma2 * np.eye(self.M)\n    B = np.dot(self.P, self.X) - np.dot(np.diag(self.P1), self.Y)\n    self.W = np.linalg.solve(A, B)\n</code></pre>"},{"location":"reference/skeleton_refinement/deformable_registration/#skeleton_refinement.deformable_registration.DeformableRegistration.update_variance","title":"<code>update_variance()</code>","text":"<p>???</p> Source code in <code>skeleton_refinement/deformable_registration.py</code> <pre><code>def update_variance(self):\n    \"\"\"???\"\"\"\n    qprev = self.sigma2\n\n    xPx = np.dot(np.transpose(self.Pt1), np.sum(np.multiply(self.X, self.X), axis=1))\n    yPy = np.dot(np.transpose(self.P1), np.sum(np.multiply(self.TY, self.TY), axis=1))\n    trPXY = np.sum(np.multiply(self.TY, np.dot(self.P, self.X)))\n\n    self.sigma2 = (xPx - 2 * trPXY + yPy) / (self.Np * self.D)\n\n    if self.sigma2 &lt;= 0:\n        self.sigma2 = self.tolerance / 10\n    self.err = np.abs(self.sigma2 - qprev)\n</code></pre>"},{"location":"reference/skeleton_refinement/expectation_maximization_registration/","title":"expectation_maximization_registration","text":"<p>This is a part of the implementation of the stochastic registration algorithm based on the following paper: Andriy Myronenko and Xubo Song, \"Point set registration: Coherent Point drift\", IEEE Transactions on Pattern Analysis and Machine Intelligence. 32 (2): 2262-2275, 2010.</p> <p>The library is based on the python implementation of the paper in pycpd package.</p>"},{"location":"reference/skeleton_refinement/expectation_maximization_registration/#skeleton_refinement.expectation_maximization_registration.ExpectationMaximizationRegistration","title":"<code>ExpectationMaximizationRegistration(X, Y, sigma2=None, max_iterations=100, tolerance=0.001, w=0, *args, **kwargs)</code>","text":"<p>             Bases: <code>object</code></p> <p>Abstract base class for all Expectation-Maximization registration algorithms.</p> <p>Attributes:</p> Name Type Description <code>X</code> <code>ndarray</code> <p>The reference point cloud coordinates of shape <code>(n_points, dim)</code>, XYZ sorted.</p> <code>Y</code> <code>ndarray</code> <p>The initial point cloud coordinates to optimize of shape <code>(n_points, dim)</code>, XYZ sorted.</p> <code>TY</code> <code>ndarray</code> <p>The optimized point cloud coordinates of shape <code>(n_points, dim)</code>, XYZ sorted.</p> <code>sigma2</code> <code>ndarray</code> <p>???</p> <code>N</code> <code>int</code> <p>The number of reference points.</p> <code>M</code> <code>int</code> <p>The number of target points.</p> <code>D</code> <code>int</code> <p>The dimensionality of the reference points, i.e. <code>3</code> for 3D point clouds.</p> <code>tolerance</code> <code>float</code> <p>??? Tolerance for registration.</p> <code>w</code> <code>int</code> <p>???</p> <code>max_iterations</code> <code>int</code> <p>The maximum number of iterations before stopping the iterative registration.</p> <code>iteration</code> <code>int</code> <p>The current iteration number.</p> <code>err</code> <code>float</code> <p>???</p> <code>P</code> <code>ndarray</code> <p>???</p> <code>Pt1</code> <code>ndarray</code> <p>???</p> <code>P1</code> <code>ndarray</code> <p>???</p> <code>Np</code> <code>int</code> <p>???</p> <p>Expectation-Maximization registration algorithms constructor.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>The reference point cloud coordinates of shape <code>(n_points, dim)</code>, XYZ sorted.</p> required <code>Y</code> <code>ndarray</code> <p>The initial point cloud coordinates to optimize of shape <code>(n_points, dim)</code>, XYZ sorted.</p> required <code>sigma2</code> <code>ndarray</code> <p>??? Defaults to <code>None</code>.</p> <code>None</code> <code>max_iterations</code> <code>int</code> <p>The maximum number of iterations before stopping the iterative registration. Defaults to <code>100</code>.</p> <code>100</code> <code>tolerance</code> <code>float</code> <p>??? Tolerance for registration. Defaults to <code>0.001</code>.</p> <code>0.001</code> <code>w</code> <code>int</code> <p>??? Defaults to <code>0</code>.</p> <code>0</code> Source code in <code>skeleton_refinement/expectation_maximization_registration.py</code> <pre><code>def __init__(self, X, Y, sigma2=None, max_iterations=100, tolerance=0.001, w=0, *args, **kwargs):\n    \"\"\"Expectation-Maximization registration algorithms constructor.\n\n    Parameters\n    ----------\n    X : numpy.ndarray\n        The reference point cloud coordinates of shape `(n_points, dim)`, XYZ sorted.\n    Y : numpy.ndarray\n        The initial point cloud coordinates to optimize of shape `(n_points, dim)`, XYZ sorted.\n    sigma2 : numpy.ndarray, optional\n        ???\n        Defaults to `None`.\n    max_iterations : int, optional\n        The maximum number of iterations before stopping the iterative registration.\n        Defaults to `100`.\n    tolerance : float, optional\n        ??? Tolerance for registration.\n        Defaults to `0.001`.\n    w : int, optional\n        ???\n        Defaults to `0`.\n    \"\"\"\n    if not isinstance(X, np.ndarray) or X.ndim != 2:\n        raise ValueError(\"The target point cloud (X) must be at a 2D numpy array.\")\n    if not isinstance(Y, np.ndarray) or Y.ndim != 2:\n        raise ValueError(\"The source point cloud (Y) must be a 2D numpy array.\")\n    if X.shape[1] != Y.shape[1]:\n        raise ValueError(\"Both point clouds need to have the same number of dimensions.\")\n\n    self.X = X\n    self.Y = Y\n    self.sigma2 = sigma2\n    (self.N, self.D) = self.X.shape\n    (self.M, _) = self.Y.shape\n    self.tolerance = tolerance\n    self.w = w\n    self.max_iterations = max_iterations\n    self.iteration = 0\n    self.err = self.tolerance + 1\n    self.P = np.zeros((self.M, self.N))\n    self.Pt1 = np.zeros((self.N,))\n    self.P1 = np.zeros((self.M,))\n    self.Np = 0\n\n    self.TY = None\n</code></pre>"},{"location":"reference/skeleton_refinement/expectation_maximization_registration/#skeleton_refinement.expectation_maximization_registration.ExpectationMaximizationRegistration.expectation","title":"<code>expectation()</code>","text":"<p>Expectation step, estimates which Gaussian the observed point cloud was sampled from.</p> Source code in <code>skeleton_refinement/expectation_maximization_registration.py</code> <pre><code>def expectation(self):\n    \"\"\"Expectation step, estimates which Gaussian the observed point cloud was sampled from.\"\"\"\n    P = np.zeros((self.M, self.N))\n\n    for i in range(0, self.M):\n        diff = self.X - np.tile(self.TY[i, :], (self.N, 1))\n        diff = np.multiply(diff, diff)\n        P[i, :] = P[i, :] + np.sum(diff, axis=1)\n\n    c = (2 * np.pi * self.sigma2) ** (self.D / 2)\n    c = c * self.w / (1 - self.w)\n    c = c * self.M / self.N\n\n    P = np.exp(-P / (2 * self.sigma2))\n    den = np.sum(P, axis=0)\n    den = np.tile(den, (self.M, 1))\n    den[den == 0] = np.finfo(float).eps\n    den += c\n\n    self.P = np.divide(P, den)\n    self.Pt1 = np.sum(self.P, axis=0)\n    self.P1 = np.sum(self.P, axis=1)\n    self.Np = np.sum(self.P1)\n</code></pre>"},{"location":"reference/skeleton_refinement/expectation_maximization_registration/#skeleton_refinement.expectation_maximization_registration.ExpectationMaximizationRegistration.get_registration_parameters","title":"<code>get_registration_parameters()</code>","text":"<p>Abstract method to implement.</p> Source code in <code>skeleton_refinement/expectation_maximization_registration.py</code> <pre><code>def get_registration_parameters(self):\n    \"\"\"Abstract method to implement.\"\"\"\n    raise NotImplementedError(\"Registration parameters should be defined in child classes.\")\n</code></pre>"},{"location":"reference/skeleton_refinement/expectation_maximization_registration/#skeleton_refinement.expectation_maximization_registration.ExpectationMaximizationRegistration.iterate","title":"<code>iterate()</code>","text":"<p>Perform one Expectation-Maximization iteration.</p> Source code in <code>skeleton_refinement/expectation_maximization_registration.py</code> <pre><code>def iterate(self):\n    \"\"\"Perform one Expectation-Maximization iteration.\"\"\"\n    self.expectation()\n    self.maximization()\n    self.iteration += 1\n</code></pre>"},{"location":"reference/skeleton_refinement/expectation_maximization_registration/#skeleton_refinement.expectation_maximization_registration.ExpectationMaximizationRegistration.maximization","title":"<code>maximization()</code>","text":"<p>Maximization step, maximizes the negative log-likelihood that the observed points were sampled from the Gaussian Mixture Model (GMM) with respect to the model parameters.</p> Source code in <code>skeleton_refinement/expectation_maximization_registration.py</code> <pre><code>def maximization(self):\n    \"\"\"Maximization step, maximizes the negative log-likelihood that the observed points were sampled from the Gaussian Mixture Model (GMM) with respect to the model parameters.\"\"\"\n    self.update_transform()\n    self.transform_point_cloud()\n    self.update_variance()\n</code></pre>"},{"location":"reference/skeleton_refinement/expectation_maximization_registration/#skeleton_refinement.expectation_maximization_registration.ExpectationMaximizationRegistration.register","title":"<code>register(callback=lambda **kwargs: None)</code>","text":"<p>???</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>function</code> <p>???</p> <code>lambda **kwargs: None</code> Source code in <code>skeleton_refinement/expectation_maximization_registration.py</code> <pre><code>def register(self, callback=lambda **kwargs: None):\n    \"\"\"???\n\n    Parameters\n    ----------\n    callback : function\n        ???\n    \"\"\"\n    self.transform_point_cloud()\n    if self.sigma2 is None:\n        self.sigma2 = initialize_sigma2(self.X, self.TY)\n    self.q = -self.err - self.N * self.D / 2 * np.log(self.sigma2)\n    while self.iteration &lt; self.max_iterations and self.err &gt; self.tolerance:\n        self.iterate()\n        if callable(callback):\n            kwargs = {'iteration': self.iteration, 'error': self.err, 'X': self.X, 'Y': self.TY}\n            callback(**kwargs)\n\n    return self.TY, self.get_registration_parameters()\n</code></pre>"},{"location":"reference/skeleton_refinement/expectation_maximization_registration/#skeleton_refinement.expectation_maximization_registration.ExpectationMaximizationRegistration.transform_point_cloud","title":"<code>transform_point_cloud()</code>","text":"<p>Abstract method to implement.</p> Source code in <code>skeleton_refinement/expectation_maximization_registration.py</code> <pre><code>def transform_point_cloud(self):\n    \"\"\"Abstract method to implement.\"\"\"\n    raise NotImplementedError(\"This method should be defined in child classes.\")\n</code></pre>"},{"location":"reference/skeleton_refinement/expectation_maximization_registration/#skeleton_refinement.expectation_maximization_registration.ExpectationMaximizationRegistration.update_transform","title":"<code>update_transform()</code>","text":"<p>Abstract method to implement.</p> Source code in <code>skeleton_refinement/expectation_maximization_registration.py</code> <pre><code>def update_transform(self):\n    \"\"\"Abstract method to implement.\"\"\"\n    raise NotImplementedError(\"This method should be defined in child classes.\")\n</code></pre>"},{"location":"reference/skeleton_refinement/expectation_maximization_registration/#skeleton_refinement.expectation_maximization_registration.ExpectationMaximizationRegistration.update_variance","title":"<code>update_variance()</code>","text":"<p>Abstract method to implement.</p> Source code in <code>skeleton_refinement/expectation_maximization_registration.py</code> <pre><code>def update_variance(self):\n    \"\"\"Abstract method to implement.\"\"\"\n    raise NotImplementedError(\"This method should be defined in child classes.\")\n</code></pre>"},{"location":"reference/skeleton_refinement/stochastic_registration/","title":"stochastic_registration","text":"<p>This code implements the basic structure of for performing the stochastic optimization algorithm. Given two set of discrete points, this code returns the transformed point set.</p>"},{"location":"reference/skeleton_refinement/stochastic_registration/#skeleton_refinement.stochastic_registration.perform_registration","title":"<code>perform_registration(X, Y)</code>","text":"<p>Performs the skeleton optimization using stochastic deformation registration.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>The input reference point cloud coordinates of shape <code>(n_points, dim)</code>, XYZ sorted.</p> required <code>Y</code> <code>ndarray</code> <p>The input reference skeleton coordinates of shape <code>(n_points, dim)</code>, XYZ sorted.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The transformed skeleton coordinates of shape <code>(n_points, 3)</code>, XYZ sorted.</p> Source code in <code>skeleton_refinement/stochastic_registration.py</code> <pre><code>def perform_registration(X, Y):\n    \"\"\"Performs the skeleton optimization using stochastic deformation registration.\n\n    Parameters\n    ----------\n    X : numpy.ndarray\n        The input reference point cloud coordinates of shape `(n_points, dim)`, XYZ sorted.\n    Y : numpy.ndarray\n        The input reference skeleton coordinates of shape `(n_points, dim)`, XYZ sorted.\n\n    Returns\n    -------\n    numpy.ndarray\n        The transformed skeleton coordinates of shape `(n_points, 3)`, XYZ sorted.\n    \"\"\"\n    reg = DeformableRegistration(**{'X': X, 'Y': Y})\n    reg.transform_point_cloud()\n    if reg.sigma2 is None:\n        reg.sigma2 = initialize_sigma2(reg.X, reg.TY)\n        reg.q = -reg.err - reg.N * reg.D / 2 * np.log(reg.sigma2)\n        while reg.iteration &lt; reg.max_iterations and reg.err &gt; reg.tolerance:\n            reg.iterate()\n    return reg.TY\n</code></pre>"},{"location":"reference/skeleton_refinement/utilities/","title":"utilities","text":""},{"location":"reference/skeleton_refinement/utilities/#skeleton_refinement.utilities.gaussian_kernel","title":"<code>gaussian_kernel(Y, beta)</code>","text":"<p>Gaussian kernel.</p> <p>Parameters:</p> Name Type Description Default <code>Y</code> <code>ndarray</code> <p>???</p> required <code>beta</code> <code>float</code> <p>???</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>???.</p> Source code in <code>skeleton_refinement/utilities.py</code> <pre><code>def gaussian_kernel(Y, beta):\n    \"\"\"Gaussian kernel.\n\n    Parameters\n    ----------\n    Y : numpy.ndarray\n        ???\n    beta : float\n        ???\n\n    Returns\n    -------\n    numpy.ndarray\n        ???.\n    \"\"\"\n    (M, D) = Y.shape\n    XX = np.reshape(Y, (1, M, D))\n    YY = np.reshape(Y, (M, 1, D))\n    XX = np.tile(XX, (M, 1, 1))\n    YY = np.tile(YY, (1, M, 1))\n    diff = XX - YY\n    diff = np.multiply(diff, diff)\n    diff = np.sum(diff, 2)\n    return np.exp(-diff / (2 * beta))\n</code></pre>"},{"location":"reference/skeleton_refinement/utilities/#skeleton_refinement.utilities.initialize_sigma2","title":"<code>initialize_sigma2(X, Y)</code>","text":"<p>Initialize the standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>???</p> required <code>Y</code> <code>ndarray</code> <p>???</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The standard deviation value.</p> Source code in <code>skeleton_refinement/utilities.py</code> <pre><code>def initialize_sigma2(X, Y):\n    \"\"\"Initialize the standard deviation.\n\n    Parameters\n    ----------\n    X : numpy.ndarray\n        ???\n    Y : numpy.ndarray\n        ???\n\n    Returns\n    -------\n    numpy.ndarray\n        The standard deviation value.\n    \"\"\"\n    (N, D) = X.shape\n    (M, _) = Y.shape\n    XX = np.reshape(X, (1, N, D))\n    YY = np.reshape(Y, (M, 1, D))\n    XX = np.tile(XX, (M, 1, 1))\n    YY = np.tile(YY, (1, N, 1))\n    diff = XX - YY\n    err = np.multiply(diff, diff)\n    return np.sum(err) / (D * M * N)\n</code></pre>"},{"location":"reference/skeleton_refinement/utilities/#skeleton_refinement.utilities.load_json","title":"<code>load_json(filename, key=None)</code>","text":"<p>Load a point cloud or skeleton file from a json file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>Path to the point cloud or skeleton file to parse.</p> required <code>key</code> <code>str</code> <p>The key of the JSON dictionary containing the point cloud or skeleton coordinates to load.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The XYZ coordinates of the point cloud or skeleton.</p> Source code in <code>skeleton_refinement/utilities.py</code> <pre><code>def load_json(filename, key=None):\n    \"\"\"Load a point cloud or skeleton file from a json file.\n    Parameters\n    ----------\n    filename : str or pathlib.Path\n        Path to the point cloud or skeleton file to parse.\n    key : str, optional\n        The key of the JSON dictionary containing the point cloud or skeleton coordinates to load.\n\n    Returns\n    -------\n    numpy.ndarray\n        The XYZ coordinates of the point cloud or skeleton.\n    \"\"\"\n    import json\n    with open(filename, mode='rb') as f:\n        X = json.load(f)\n\n    if key is not None:\n        X = X[key]\n    return np.array(X)\n</code></pre>"},{"location":"reference/skeleton_refinement/utilities/#skeleton_refinement.utilities.load_ply","title":"<code>load_ply(filename)</code>","text":"<p>Load a point cloud coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>Path to the point cloud ofile to parse.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The XYZ coordinates of the point cloud or skeleton.</p> Source code in <code>skeleton_refinement/utilities.py</code> <pre><code>def load_ply(filename):\n    \"\"\"Load a point cloud coordinates.\n\n    Parameters\n    ----------\n    filename : str or pathlib.Path\n        Path to the point cloud ofile to parse.\n\n    Returns\n    -------\n    numpy.ndarray\n        The XYZ coordinates of the point cloud or skeleton.\n    \"\"\"\n    from plyfile import PlyData\n    plydata = PlyData.read(filename)\n    X = np.array([plydata['vertex']['x'], plydata['vertex']['y'], plydata['vertex']['z']]).T\n    return X\n</code></pre>"},{"location":"reference/skeleton_refinement/utilities/#skeleton_refinement.utilities.load_xyz","title":"<code>load_xyz(filename)</code>","text":"<p>Load a point cloud or skeleton file saved as a series of space-separated XYZ coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>Path to the point cloud or skeleton file to parse.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The XYZ coordinates of the point cloud or skeleton.</p> Source code in <code>skeleton_refinement/utilities.py</code> <pre><code>def load_xyz(filename):\n    \"\"\"Load a point cloud or skeleton file saved as a series of space-separated XYZ coordinates.\n\n    Parameters\n    ----------\n    filename : str or pathlib.Path\n        Path to the point cloud or skeleton file to parse.\n\n    Returns\n    -------\n    numpy.ndarray\n        The XYZ coordinates of the point cloud or skeleton.\n    \"\"\"\n    f = open(filename, \"r\")\n    lines = f.readlines()\n    org_x = []\n    org_y = []\n    org_z = []\n    for l in lines:\n        org_x.append(float(l.split(' ')[0]))\n        org_y.append(float(l.split(' ')[1]))\n        org_z.append(float(l.split(' ')[2]))\n    f.close()\n    X = np.column_stack((org_x, org_y, org_z))\n    return X\n</code></pre>"},{"location":"reference/skeleton_refinement/cli/","title":"cli","text":""},{"location":"reference/skeleton_refinement/cli/refine_skeleton/","title":"refine_skeleton","text":"<p>This program performs refinement of an existing skeleton (in the form of 3D point cloud data) of a plant starting from it's initial \"coarse\" structure. The coarse skeleton is \"rectified\" via a stochastic optimization framework, by \"pushing\" the skeleton points towards the original point cloud data so that they get \"aligned\" in space. There are two parameters that control the quality of alignment, alpha and beta (denoted as 'myAlpha' and 'myBeta' in 'param_settings.py')</p> <p>Author: Ayan Chaudhury INRIA team MOSAIC</p>"},{"location":"reference/skeleton_refinement/cli/refine_skeleton/#skeleton_refinement.cli.refine_skeleton.file_loader","title":"<code>file_loader(fname)</code>","text":"<p>Load point cloud or skeleton from a file.</p> Source code in <code>skeleton_refinement/cli/refine_skeleton.py</code> <pre><code>def file_loader(fname):\n    \"\"\"Load point cloud or skeleton from a file.\"\"\"\n    fname = Path(fname)\n    if fname.suffix == \".xyz\":\n        xyz = load_xyz(fname)\n    elif fname.suffix == \".json\":\n        xyz = load_json(fname, \"points\")\n    elif fname.suffix == \".ply\":\n        xyz = load_ply(fname)\n    else:\n        raise IOError(\"Unknown file format!\")\n    return xyz\n</code></pre>"}]}